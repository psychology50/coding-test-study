# BOJ-10835

## 문제 설명

두 더미의 카드가 주어졌을 때, 게임을 통해 얻을 수 있는 최종 점수의 최댓값을 출력하는 프로그램을 만드는 문제

### 문제 규칙

1. 언제든지 왼쪽 카드만 통에 버릴 수도 있고 왼쪽 카드와 오른쪽 카드를 둘 다 통에 버릴 수도 있다. 이때 얻는 점수는 없다.
2. 오른쪽 카드에 적힌 수가 왼쪽 카드에 적힌 수보다 작은 경우에는 오른쪽 카드만 통에 버릴 수도 있다. **오른쪽 카드만 버리는 경우에는 오른쪽 카드에 적힌 수만큼 점수**를 얻는다.
3. (1)과 (2)의 규칙에 따라 게임을 진행하다가 어느 쪽 더미든 남은 카드가 없다면 게임이 끝나며 그때까지 얻은 점수의 합이 최종 점수가 된다.

| 카드 순서 | 왼쪽 카드 | 오른쪽 카드 |
| :-------: | :-------: | :---------: |
|     1     |     3     |      2      |
|     2     |     2     |      4      |
|     3     |     5     |      1      |

위와 같이 카드가 주어졌을 때 점수의 최대값을 만들기 위해서는 아래와 같은 시나리오를 만들면 된다.

1. 3이 2보다 크므로, 오른쪽 카드를 버린다. (2번 규칙, 2점 획득)
2. 3이 4보다 작으므로, 왼쪽 카드만을 버린다. (1번 규칙)
3. 2가 4보다 작으므로, 왼쪽 카드만을 버린다. (1번 규칙)
4. 5가 4보다 크므로, 오른쪽 카드를 버린다. (2번 규칙, 4점 획득)
5. 5가 1보다 크므로, 오른쪽 카드를 버린다. (2번 규칙, 1점 획득)

게임 종료, 최종 점수 = 7점

## 아이디어

### BFS를 이용한 풀이

왼쪽 카드, 오른쪽 카드의 인덱스와 현재 점수를 map으로 가지고서 카드가 남지 않을때까지 bfs를 진행

```
i. if left_cards[ldx] > right_cards[rdx]:
   queue.append((ldx, rdx+1, score+right_cards[rdx]))
ii. else:
   queue.append((ldx+1, rdx, score))
   queue.append((ldx+1, rdx+1, score))
```

1. 왼쪽 카드가 오른쪽 카드보다 큰 경우, 오른쪽 \*카드를 버린(다음 인덱스로 이동) 후에 점수를 추가
2. 오른쪽 카드가 왼쪽 카드보다 크거나 같은 경우

   1. 왼쪽 카드를 버리기
   2. 왼쪽 카드와 오른쪽 카드를 둘 다 버리기

**최종 점수 합산**

왼쪽 카드 혹은 오른쪽 카드가 더 이상 없을 경우, 다음과 같이 answer과 score를 비교하여 업데이트

```
if ldx == len(left_cards) or rdx == len(right_cards):
   answer = max(answer, score)
   continue
```

![image](https://github.com/BangDori/RooTrip-Front/assets/44726494/4b9b90ff-ec50-4977-b538-07e15b1c0fe4)

시간초과 문제를 해결하기 위해 `visited` 배열을 통해 이전에 비교한 값에 대해서는 더 이상 비교하지 않는 방법을 해보려고 했는데, 머리가 굳어서 해결하지 못했음

### DFS + dp를 이용한 풀이

진우님이 1520번 문제를 해결하실 때 작성한 [풀이](https://github.com/psychology50/coding-test-study/tree/main/jinwoo/boj-1520)가 굉장히 큰 도움이 되었,, 감사합니다 😊

BFS와 동일하게 왼쪽 카드, 오른쪽 카드의 인덱스와 점수로 진행

왼쪽 카드가 더 클경우, 오른쪽 카드를 버리기

```
if left_cards[l] > right_cards[r]:
   dp[l][r] = dfs(l, r+1, point) + right_cards[r]
```

왼쪽 카드가 오른쪽 카드보다 더 작거나 같다면, 왼쪽 카드를 버리거나 혹은 왼쪽 카드와 오른쪽 카드를 둘 다 버리기

```
else:
   throw_left = dfs(l+1, r, point)
   throw_all = dfs(l+1, r+1, point)

   dp[l][r] = max(throw_left, throw_all)
```

**DFS 탐색 종료 조건:**

1. 카드가 더 이상 존재하지 않는 경우

```
if l == cards or r == cards:
   return point
```

2. **DP에 저장된 dp[l][r] 값이 -1이 아닌 경우** ★★★

```
if dp[l][r] != -1:
   return dp[l][r]
```

2번을 종료 조건을 추가해주지 않으면 시간초과 때문에, 31점 밖에 받지 못함.

만약 dp[l][r] 값이 존재한다면, 이전에 왼쪽 l번째 카드와 오른쪽 r번째 카드를 비교한 결과값을 저장하고 있다는 것을 의미하기 때문에,

dp[l][r]이 -1이라면 dp[l][r]을 반환하게 하여 메모이제이션 하기

## 결론

어떻게든 풀어보려고 밤새면서 했는데, 3일동안 못풀었어요 ㅜㅜ

그래도 열심히 손으로 끄적이다가, 뭔가 DFS를 이용해서 문제를 해결할 수 있을 거 같아서 DFS로 어떻게든 해결해보려고 했는데 64점의 벽에 막혀버렸어요.

그래서 6~7일차부터 아예 감이 안잡혀서 진우님이 전에 작성하신 풀이도 보고 다른 사람들이 작성한 코드도 좀 봤던거 같습니다 🥲🥲
