# BOJ-2206

### 문제

- N x M의 행렬로 표현된 맵이 존재
- 맵에서 이동 가능한 공간 (0), 이동 불가능한 공간 (1) 으로 나타낼 때, (1,1) -> (N, M)의 위치까지 이동하는 최단 거리
- 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 경로가 더 짧다면, 벽을 한 개 까지 부수고 이동할 수 있음
- 상하좌우로 한 칸씩 이동 가능
- 이때, **(1, 1)과 (N, M)은 항상 0**이라고 가정하자.

### 아이디어

- (1,1)을 시작 지점으로 설정 후, 탐색 시작
- 탐색은 1초에 총 4방향으로 진행, 1초가 지날 때 마다 이동 가능한 모든 경우를 queue에 저장한 후 bfs 방식으로 탐색을 진행
  - 탐색을 진행할 때 고려해야 할 두가지 경우
    ```
    1. 0을 만난 경우
      1-1. 이전에 벽을 부순 상황과 무관하게 이동이 가능
    2. 1을 만난 경우
      2-1. 이전에 벽을 부순적이 있다면 이동 불가
      2-2. 이전에 벽을 부순적이 없다면 이동 가능
    ```
- queue에 이동 가능한 위치와, 현재 벽을 부순 횟수를 저장
- dfs로 탐색을 진행하다가, 만약 dfs 내부에 최종 목적지 (N, M)이 존재한다면 큐를 비우고 종료

![image](https://github.com/BangDori/ci-cd-test/assets/44726494/92a30545-ac30-4b34-9f76-abea7a159a59)

### Wrong Answer

벽을 뚫고 최단거리로 가는 경우에 대해 에러가 발생함.

```
반례 예시
9 9
010001000
010101010
010101010
010101010
010101010
010101010
010101010
010101011
000100010

정답: 33
오답: -1
```

#### 해결 방법

- 지나가는 모든 경로에 대해 지나감을 표시 (2로 설정)
- 이때, 만약 벽을 뚫고 지나가는 경우에는 3으로 표시

벽을 하나도 뚫지 않고 이동하는 경우에 3을 만나면 2로 변경하고 이동하면서 확인
