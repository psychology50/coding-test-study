# BOJ-2636

### 문제 설명

정사각형 모양의 판이 있고, 판 내부에 치즈가 놓여있음.
**판의 가장자리에는 치즈가 놓여 있지 않음**
치즈의 구멍을 둘러싼 치즈는 녹지 않고 'c'로 표시된 부분만 한 시간 후에 녹아 없어지게 된다.

이때, 치즈가 모두 녹아서 없어지는 데 걸리는 시간과, 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 출력하자

### 내가 생각한 아이디어 (미해결)

1. 판의 가장자리부터 탐색을 시작하는 것이 아닌, 치즈가 공기에 맞닿아 있는 부분을 알아내자.
2. 치즈가 공기에 맞닿아 있는 부분을 알아낸 후, 이 부분에 대해서 계속해서 bfs를 돌리자.
   - 판의 가장자리부터 순회하는 방식이 아닌, **치즈의 가장자리 부분부터 치즈의 중앙까지 탐색을 진행**하기 때문에 시간에서 효율을 크게 볼 수 있을 것이라 생각
   - 하지만, 치즈가 공기에 맞닿아 있는 부분이 중간에 구멍이 난 부분인지에 대해서는 판단 조건을 작성하기가 힘듦.

왜 쉽게 푸는 방법을 놔두고 이렇게 돌아갔을까,,

### 참고한 아이디어

1. 입력을 받은 후, 테이블에 존재하는 **치즈의 총 개수(a)**를 저장
2. 판의 가장자리는 절대 치즈가 놓여있을 수 없기 때문에, **판의 가장자리 부터 탐색**을 시작하자.
3. 탐색은 **테이블에 치즈가 하나도 없을 때 까지** 진행

   3-1. 판의 가장자리(0,0) 부터 탐색을 시작

   3-2. 만약 이동 방향에 놓여진 칸이 공기(0) 이라면 큐에 삽입, 치즈(1) 이라면 melt 배열에 삽입

   3-3. 이동 방향에 놓여진 공기를 큐에 삽입할 때, visited 배열을 통해 중복하게 이동하는 경우를 방지

   - 만약 visited 배열을 생성하지 않고, 이동 시킬 경우 **시간 초과** 발생

   3-4. 탐색이 종료되면, 현재 판에 존재하는 치즈의 가장자리의 위치들이 melt 배열에 저장

   3-5. melt 배열에 저장된 치즈의 위치들에 대해 0으로 설정 (녹음)

   3-6. 탐색이 종료되면, **melt 배열의 치즈의 개수(b)** 를 치즈의 총 개수에서 빼주기

   - **남은 치즈의 개수 = 치즈의 총 개수(a) - 녹은 치즈의 총 개수(b)**

   3-7. 3-1 부터 탐색을 다시 시작
