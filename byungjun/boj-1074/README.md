# BOJ-1074

### 문제

Z 모양 탐색

### 아이디어

```
1. 문제에서 제공해주는 배열을 분석
2. 분할정복법을 이용하여 배열을 4등분으로 분할
3. Z 모양의 진행 과정은 아래와 같이 진행
  - 좌측 상단(1)
  - 우측 상단(2)
  - 좌측 하단(3)
  - 우측 하단(4)

  - 8x8 배열의 경우
      => (0,0), (0, 4), (4, 0), (4, 4) 4등분으로 분할
3. 계속해서 진행한 후, 문제에서 주어진 col, row를 찾으면 종료
```

### 시간 초과

- 배열을 2^n x 2^n 만큼 생성한 후에, 배열의 값을 채우고 해당 row, col 의 위치의 값을 출력하자.
  => 이 경우 만약 크기가 2^15이고, (32,767, 32,767)을 찾는다면 해당 정답인 1073741823만 알면 되지만 0, 0부터 계속 채워야 하기 떄문에 총 10억번을 돌게 됨.
  ![image](https://github.com/psychology50/coding-test-study/assets/44726494/021a2c7e-b081-418d-9538-00f08bab6e08)

### 시간 초과 해결

- 분할정복법을 이용해 (0, 0) ~ (2^n, 2^n) 값을 모두 채우지 말고, 분할 과정에서 해당하는 영역에 대해서만 계속해서 탐색한 후, 값만 출력하자.
  => 모든 부분을 탐색할 필요가 X

```
if ans_row < row+pow(2, size-1) and ans_col < col+pow(2, size-1):
  # 1
  get_Z(size-1, row, col)
elif ans_row < row+pow(2, size-1):
  # 2
  count += (pow(2, size-1) * pow(2, size-1))
  get_Z(size-1, row, col+pow(2, size-1))
elif ans_col < col+pow(2, size-1):
  # 3
  count += (pow(2, size-1) * pow(2, size-1) * 2)
  get_Z(size-1, row+pow(2, size-1), col)
else:
  # 4
  count += (pow(2, size-1) * pow(2, size-1) * 3)
  get_Z(size-1, row+pow(2, size-1), col+pow(2, size-1))
```

예를 들어, 사이즈가 4인 경우에는 배열의 크기는 16x16.

이 때, 만약 (12, 3)을 찾는다면 해당 좌표는 첫 3번 영역에 존재한다는 것을 확인할 수 있음.
이 후, (8, 0) ~ (15, 8) 까지 좌표가 좁혀졌을 경우 다시 확인

12, 3은 분할된 3번 영역 내에서 탐색을 진행. 이런식으로 탐색을 진행하며 count를 계산해준 후에 마지막에 배열의 크기가 2x2가 됐을 때,
Z 탐색을 진행

### 시간복잡도: O(log N)
