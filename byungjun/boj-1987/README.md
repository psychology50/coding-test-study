# BOJ-1987

# 문제

(0, 0) 'C' 부터 시작해서, 말이 최대 몇 칸을 지날 수 있는지에 대한 문제

```
2 4
CAAB
ADCB
```

행과 열의 크기와 보드판이 주어진다.

말은 총 4방향으로 상하좌우 방향으로 이동할 수 있다.

이때, 중요한 점은 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다.

**예시**

- (0, 0) -> (0, 1) -> (0, 2), C -> A -> A A가 두번 나오기 때문에 지나갈 수 없다.
- (0, 0) -> (0, 1) -> (1, 1), C -> A -> D 중복이 없기 때문에 3칸을 지나갈 수 있다.

# 아이디어

1. 입력받은 테이블 크기와 동일하게 visited 배열을 생성한다.
2. visited 배열에는 Boolean 타입의 값이 아닌 해당 (x, y)에 도착했을 때의 문자열을 저장한다.
3. 큐에는 좌표(x, y)와 해당 좌표까지 왔을 때의 문자열을 튜플 형태로 저장한다. => `(x, y, alphabets)`
4. (0, 0)을 시작으로 dfs를 진행한다.
   - 만약 큐에서 뺀 alphabets 길이가 count보다 길다면 count에 alphabets의 길이를 저장한다.
   - 이동하는 방향에 대해 visited 배열을 확인해, 이동할 visited 배열의 값과 alphabet과 동일하다면 이전에 이동했기 때문에 이동하지않는다.
   - alphabets에서 다음에 올 알파벳이 없다면 visited 배열에 현재 alphabets를 저장하고 큐에 넣는다.

# 시간초과

visited 배열을 활용하지 않고 바로 alphabets 배열을 이용하는 경우, 중복으로 이동하는 경우가 발생하기 때문에 시간 초과가 발생.

- visited 배열을 활용하여 시간 초과를 해결
